"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
const tslib_1 = require("tslib");
const app_root_1 = require("../utilities/app-root");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const child_process_1 = require("child_process");
const cache_directory_1 = require("../utilities/cache-directory");
const fileutils_1 = require("../utilities/fileutils");
class CacheConfig {
    constructor(options) {
        this.options = options;
    }
    isCacheableTask(task) {
        const cacheable = this.options.cacheableOperations || this.options.cacheableTargets;
        return (cacheable &&
            cacheable.indexOf(task.target.target) > -1 &&
            !this.longRunningTask(task));
    }
    longRunningTask(task) {
        return !!task.overrides['watch'];
    }
}
class Cache {
    constructor(options) {
        this.options = options;
        this.root = app_root_1.appRootPath;
        this.cachePath = this.createCacheDir();
        this.terminalOutputsDir = this.createTerminalOutputsDir();
        this.latestOutputsHashesDir = this.ensureLatestOutputsHashesDir();
        this.cacheConfig = new CacheConfig(this.options);
    }
    removeOldCacheRecords() {
        /**
         * Even though spawning a process is fast, we don't want to do it every time
         * the user runs a command. Instead, we want to do it once in a while.
         */
        const shouldSpawnProcess = Math.floor(Math.random() * 50) === 1;
        if (shouldSpawnProcess) {
            const scriptPath = require.resolve('@nrwl/workspace/src/tasks-runner/remove-old-cache-records.js', { paths: [this.root] });
            try {
                const p = child_process_1.spawn('node', [scriptPath, `"${this.cachePath}"`], {
                    stdio: 'ignore',
                    detached: true,
                });
                p.unref();
            }
            catch (e) {
                console.log(`Unable to start remove-old-cache-records script:`);
                console.log(e.message);
            }
        }
    }
    get(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.cacheConfig.isCacheableTask(task))
                return null;
            const res = this.getFromLocalDir(task);
            // didn't find it locally but we have a remote cache
            if (!res && this.options.remoteCache) {
                // attempt remote cache
                yield this.options.remoteCache.retrieve(task.hash, this.cachePath);
                // try again from local cache
                return this.getFromLocalDir(task);
            }
            else {
                return res;
            }
        });
    }
    put(task, terminalOutput, outputs, code) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const td = path_1.join(this.cachePath, task.hash);
            const tdCommit = path_1.join(this.cachePath, `${task.hash}.commit`);
            // might be left overs from partially-completed cache invocations
            fs_extra_1.removeSync(tdCommit);
            fs_extra_1.removeSync(td);
            fs_1.mkdirSync(td);
            fs_1.writeFileSync(path_1.join(td, 'terminalOutput'), terminalOutput !== null && terminalOutput !== void 0 ? terminalOutput : 'no terminal output');
            fs_1.mkdirSync(path_1.join(td, 'outputs'));
            outputs.forEach((f) => {
                const src = path_1.join(this.root, f);
                if (fs_1.existsSync(src)) {
                    const cached = path_1.join(td, 'outputs', f);
                    // Ensure parent directory is created if src is a file
                    const isFile = fs_1.lstatSync(src).isFile();
                    const directory = isFile ? path_1.resolve(cached, '..') : cached;
                    fs_extra_1.ensureDirSync(directory);
                    fs_extra_1.copySync(src, cached);
                }
            });
            // we need this file to account for partial writes to the cache folder.
            // creating this file is atomic, whereas creating a folder is not.
            // so if the process gets terminated while we are copying stuff into cache,
            // the cache entry won't be used.
            fs_1.writeFileSync(path_1.join(td, 'code'), code.toString());
            fs_1.writeFileSync(tdCommit, 'true');
            if (this.options.remoteCache) {
                yield this.options.remoteCache.store(task.hash, this.cachePath);
            }
        });
    }
    copyFilesFromCache(hash, cachedResult, outputs) {
        this.removeRecordedOutputsHashes(outputs);
        outputs.forEach((f) => {
            const cached = path_1.join(cachedResult.outputsPath, f);
            if (fs_1.existsSync(cached)) {
                const isFile = fs_1.lstatSync(cached).isFile();
                const src = path_1.join(this.root, f);
                fs_extra_1.removeSync(src);
                // Ensure parent directory is created if src is a file
                const directory = isFile ? path_1.resolve(src, '..') : src;
                fs_extra_1.ensureDirSync(directory);
                fs_extra_1.copySync(cached, src);
            }
        });
        this.recordOutputsHash(outputs, hash);
    }
    temporaryOutputPath(task) {
        if (this.cacheConfig.isCacheableTask(task)) {
            return path_1.join(this.terminalOutputsDir, task.hash);
        }
        else {
            return null;
        }
    }
    removeRecordedOutputsHashes(outputs) {
        outputs.forEach((output) => {
            const hashFile = this.getFileNameWithLatestRecordedHashForOutput(output);
            try {
                fs_1.unlinkSync(hashFile);
            }
            catch (e) { }
        });
    }
    recordOutputsHash(outputs, hash) {
        outputs.forEach((output) => {
            const hashFile = this.getFileNameWithLatestRecordedHashForOutput(output);
            fileutils_1.writeToFile(hashFile, hash);
        });
    }
    shouldCopyOutputsFromCache(taskWithCachedResult, outputs) {
        return (this.areLatestOutputsHashesDifferentThanTaskHash(outputs, taskWithCachedResult.task.hash) || this.isAnyOutputMissing(taskWithCachedResult.cachedResult, outputs));
    }
    areLatestOutputsHashesDifferentThanTaskHash(outputs, hash) {
        return outputs.some((output) => this.getLatestRecordedHashForTask(output) !== hash);
    }
    getLatestRecordedHashForTask(output) {
        try {
            return fs_1.readFileSync(this.getFileNameWithLatestRecordedHashForOutput(output)).toString();
        }
        catch (e) {
            return null;
        }
    }
    isAnyOutputMissing(cachedResult, outputs) {
        return outputs.some((output) => fs_1.existsSync(path_1.join(cachedResult.outputsPath, output)) &&
            !fs_1.existsSync(path_1.join(this.root, output)));
    }
    getFileNameWithLatestRecordedHashForOutput(output) {
        return path_1.join(this.latestOutputsHashesDir, `${output.split(path_1.sep).join('-')}.hash`);
    }
    getFromLocalDir(task) {
        const tdCommit = path_1.join(this.cachePath, `${task.hash}.commit`);
        const td = path_1.join(this.cachePath, task.hash);
        if (fs_1.existsSync(tdCommit)) {
            const terminalOutput = fs_1.readFileSync(path_1.join(td, 'terminalOutput'), 'utf-8');
            let code = 0;
            try {
                code = Number(fs_1.readFileSync(path_1.join(td, 'code'), 'utf-8'));
            }
            catch (e) { }
            return {
                terminalOutput,
                outputsPath: path_1.join(td, 'outputs'),
                code,
            };
        }
        else {
            return null;
        }
    }
    createCacheDir() {
        const dir = cache_directory_1.cacheDirectory(this.root, this.options.cacheDirectory);
        fs_extra_1.ensureDirSync(dir);
        return dir;
    }
    createTerminalOutputsDir() {
        const path = path_1.join(this.cachePath, 'terminalOutputs');
        fs_extra_1.ensureDirSync(path);
        return path;
    }
    ensureLatestOutputsHashesDir() {
        const path = path_1.join(this.cachePath, 'latestOutputsHashes');
        fs_extra_1.ensureDirSync(path);
        return path;
    }
}
exports.Cache = Cache;
//# sourceMappingURL=cache.js.map