"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRunner = exports.createTask = exports.createTasksForProjectToRun = exports.runCommand = void 0;
const tslib_1 = require("tslib");
const tasks_runner_1 = require("./tasks-runner");
const path_1 = require("path");
const app_root_1 = require("../utilities/app-root");
const fileutils_1 = require("../utilities/fileutils");
const project_graph_utils_1 = require("../utilities/project-graph-utils");
const output_1 = require("../utilities/output");
const utils_1 = require("./utils");
const hasher_1 = require("../core/hasher/hasher");
function runCommand(projectsToRun, projectGraph, { nxJson, workspaceResults }, nxArgs, overrides, reporter, initiatingProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { tasksRunner, runnerOptions } = getRunner(nxArgs, nxJson);
        const defaultDependencyConfigs = utils_1.getDefaultDependencyConfigs(nxJson);
        const tasks = createTasksForProjectToRun(projectsToRun, {
            target: nxArgs.target,
            configuration: nxArgs.configuration,
            overrides,
        }, projectGraph, initiatingProject, defaultDependencyConfigs);
        reporter.beforeRun(projectsToRun.map((p) => p.name), tasks, nxArgs, overrides);
        // TODO: vsavkin remove hashing after Nx 13
        const hasher = new hasher_1.Hasher(projectGraph, nxJson, runnerOptions);
        const res = yield Promise.all(tasks.map((t) => hasher.hashTaskWithDepsAndContext(t)));
        for (let i = 0; i < res.length; ++i) {
            tasks[i].hash = res[i].value;
            tasks[i].hashDetails = res[i].details;
        }
        const cachedTasks = [];
        const failedTasks = [];
        const tasksWithFailedDependencies = [];
        tasksRunner(tasks, runnerOptions, {
            initiatingProject,
            target: nxArgs.target,
            projectGraph,
            nxJson,
            hideCachedOutput: nxArgs.hideCachedOutput,
        }).subscribe({
            next: (event) => {
                switch (event.type) {
                    case tasks_runner_1.AffectedEventType.TaskComplete: {
                        if (projectsToRun
                            .map((project) => project.name)
                            .includes(event.task.target.project) &&
                            event.task.target.target === nxArgs.target) {
                            workspaceResults.setResult(event.task.target.project, event.success);
                        }
                        if (!event.success) {
                            failedTasks.push(event.task);
                        }
                        break;
                    }
                    case tasks_runner_1.AffectedEventType.TaskDependencyFailed: {
                        tasksWithFailedDependencies.push(event.task);
                        break;
                    }
                    case tasks_runner_1.AffectedEventType.TaskCacheRead: {
                        if (projectsToRun
                            .map((project) => project.name)
                            .includes(event.task.target.project) &&
                            event.task.target.target === nxArgs.target) {
                            workspaceResults.setResult(event.task.target.project, event.success);
                        }
                        cachedTasks.push(event.task);
                        if (!event.success) {
                            failedTasks.push(event.task);
                        }
                        break;
                    }
                }
            },
            error: console.error,
            complete: () => {
                // fix for https://github.com/nrwl/nx/issues/1666
                if (process.stdin['unref'])
                    process.stdin.unref();
                workspaceResults.saveResults();
                reporter.printResults(nxArgs, workspaceResults.startedWithFailedProjects, tasks, failedTasks, tasksWithFailedDependencies, cachedTasks);
                if (workspaceResults.hasFailure) {
                    process.exit(1);
                }
            },
        });
    });
}
exports.runCommand = runCommand;
function createTasksForProjectToRun(projectsToRun, params, projectGraph, initiatingProject, defaultDependencyConfigs = {}) {
    const tasksMap = new Map();
    for (const project of projectsToRun) {
        addTasksForProjectTarget(Object.assign(Object.assign({ project }, params), { errorIfCannotFindConfiguration: project.name === initiatingProject }), defaultDependencyConfigs, projectGraph, tasksMap, []);
    }
    return Array.from(tasksMap.values());
}
exports.createTasksForProjectToRun = createTasksForProjectToRun;
function addTasksForProjectTarget({ project, target, configuration, overrides, errorIfCannotFindConfiguration, }, defaultDependencyConfigs = {}, projectGraph, tasksMap, path) {
    const task = createTask({
        project,
        target,
        configuration,
        overrides,
        errorIfCannotFindConfiguration,
    });
    const dependencyConfigs = utils_1.getDependencyConfigs({ project: project.name, target }, defaultDependencyConfigs, projectGraph);
    if (dependencyConfigs) {
        for (const dependencyConfig of dependencyConfigs) {
            addTasksForProjectDependencyConfig(project, {
                target,
                configuration,
            }, dependencyConfig, defaultDependencyConfigs, projectGraph, tasksMap, path);
        }
    }
    tasksMap.set(task.id, task);
}
function createTask({ project, target, configuration, overrides, errorIfCannotFindConfiguration, }) {
    if (!project_graph_utils_1.projectHasTarget(project, target)) {
        output_1.output.error({
            title: `Cannot find target '${target}' for project '${project.name}'`,
        });
        process.exit(1);
    }
    const config = project_graph_utils_1.projectHasTargetAndConfiguration(project, target, configuration)
        ? configuration
        : undefined;
    if (errorIfCannotFindConfiguration && configuration && !config) {
        output_1.output.error({
            title: `Cannot find configuration '${configuration}' for project '${project.name}:${target}'`,
        });
        process.exit(1);
    }
    const qualifiedTarget = {
        project: project.name,
        target,
        configuration: config,
    };
    return {
        id: getId(qualifiedTarget),
        target: qualifiedTarget,
        projectRoot: project.data.root,
        overrides: interpolateOverrides(overrides, project.name, project.data),
    };
}
exports.createTask = createTask;
function addTasksForProjectDependencyConfig(project, { target, configuration }, dependencyConfig, defaultDependencyConfigs, projectGraph, tasksMap, path) {
    const targetIdentifier = getId({
        project: project.name,
        target,
        configuration,
    });
    if (path.includes(targetIdentifier)) {
        output_1.output.error({
            title: `Could not execute ${path[0]} because it has a circular dependency`,
            bodyLines: [`${[...path, targetIdentifier].join(' --> ')}`],
        });
        process.exit(1);
    }
    if (tasksMap.has(targetIdentifier)) {
        return;
    }
    if (dependencyConfig.projects === 'dependencies') {
        const dependencies = projectGraph.dependencies[project.name];
        for (const dep of dependencies) {
            const depProject = projectGraph.nodes[dep.target];
            if (project_graph_utils_1.projectHasTarget(depProject, dependencyConfig.target)) {
                addTasksForProjectTarget({
                    project: projectGraph.nodes[dep.target],
                    target: dependencyConfig.target,
                    configuration,
                    overrides: {},
                    errorIfCannotFindConfiguration: false,
                }, defaultDependencyConfigs, projectGraph, tasksMap, [...path, targetIdentifier]);
            }
        }
    }
    else {
        addTasksForProjectTarget({
            project,
            target: dependencyConfig.target,
            configuration,
            overrides: {},
            errorIfCannotFindConfiguration: true,
        }, defaultDependencyConfigs, projectGraph, tasksMap, [...path, targetIdentifier]);
    }
}
function getId({ project, target, configuration, }) {
    let id = `${project}:${target}`;
    if (configuration) {
        id += `:${configuration}`;
    }
    return id;
}
function getRunner(nxArgs, nxJson) {
    let runner = nxArgs.runner;
    //TODO: vsavkin remove in Nx 12
    if (!nxJson.tasksRunnerOptions) {
        const t = require('./default-tasks-runner');
        return {
            tasksRunner: t.defaultTasksRunner,
            runnerOptions: nxArgs,
        };
    }
    //TODO: vsavkin remove in Nx 12
    if (!runner && !nxJson.tasksRunnerOptions.default) {
        const t = require('./default-tasks-runner');
        return {
            tasksRunner: t.defaultTasksRunner,
            runnerOptions: nxArgs,
        };
    }
    runner = runner || 'default';
    if (nxJson.tasksRunnerOptions[runner]) {
        let modulePath = nxJson.tasksRunnerOptions[runner].runner;
        let tasksRunner;
        if (modulePath) {
            if (fileutils_1.isRelativePath(modulePath)) {
                modulePath = path_1.join(app_root_1.appRootPath, modulePath);
            }
            tasksRunner = require(modulePath);
            // to support both babel and ts formats
            if (tasksRunner.default) {
                tasksRunner = tasksRunner.default;
            }
        }
        else {
            tasksRunner = require('./default-tasks-runner').defaultTasksRunner;
        }
        return {
            tasksRunner,
            runnerOptions: Object.assign(Object.assign({}, nxJson.tasksRunnerOptions[runner].options), nxArgs),
        };
    }
    else {
        output_1.output.error({
            title: `Could not find runner configuration for ${runner}`,
        });
        process.exit(1);
    }
}
exports.getRunner = getRunner;
function interpolateOverrides(args, projectName, projectMetadata) {
    const interpolatedArgs = Object.assign({}, args);
    Object.entries(interpolatedArgs).forEach(([name, value]) => {
        if (typeof value === 'string') {
            const regex = /{project\.([^}]+)}/g;
            interpolatedArgs[name] = value.replace(regex, (_, group) => {
                if (group.includes('.')) {
                    throw new Error('Only top-level properties can be interpolated');
                }
                if (group === 'name') {
                    return projectName;
                }
                return projectMetadata[group];
            });
        }
    });
    return interpolatedArgs;
}
//# sourceMappingURL=run-command.js.map