"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskOrchestrator = void 0;
const tslib_1 = require("tslib");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const child_process_1 = require("child_process");
const dotenv = require("dotenv");
const fs_1 = require("fs");
const app_root_1 = require("../utilities/app-root");
const output_1 = require("../utilities/output");
const cache_1 = require("./cache");
const tasks_runner_1 = require("./tasks-runner");
const utils_1 = require("./utils");
const perf_hooks_1 = require("perf_hooks");
class TaskOrchestrator {
    constructor(hasher, initiatingProject, projectGraph, taskGraph, options, hideCachedOutput) {
        this.hasher = hasher;
        this.initiatingProject = initiatingProject;
        this.projectGraph = projectGraph;
        this.taskGraph = taskGraph;
        this.options = options;
        this.hideCachedOutput = hideCachedOutput;
        this.workspaceRoot = app_root_1.appRootPath;
        this.cache = new cache_1.Cache(this.options);
        this.timings = {};
        this.completedTasks = {};
        this.inProgressTasks = {};
        this.scheduledTasks = [];
        this.waitingForTasks = [];
        this.reverseTaskDeps = {};
        this.processes = [];
        this.setupOnProcessExitListener();
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.calculateReverseDeps();
            for (let root of this.taskGraph.roots) {
                yield this.scheduleTask(root);
            }
            perf_hooks_1.performance.mark('task-execution-begins');
            const res = yield this.runTasks();
            perf_hooks_1.performance.mark('task-execution-ends');
            perf_hooks_1.performance.measure('command-execution', 'task-execution-begins', 'task-execution-ends');
            this.cache.removeOldCacheRecords();
            return res;
        });
    }
    calculateReverseDeps() {
        Object.keys(this.taskGraph.tasks).forEach((t) => {
            this.reverseTaskDeps[t] = [];
        });
        Object.keys(this.taskGraph.dependencies).forEach((taskId) => {
            this.taskGraph.dependencies[taskId].forEach((d) => {
                this.reverseTaskDeps[d].push(taskId);
            });
        });
    }
    nextTask() {
        if (this.scheduledTasks.length > 0) {
            return this.taskGraph.tasks[this.scheduledTasks.pop()];
        }
        else {
            return null;
        }
    }
    complete(taskId, status) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.completedTasks[taskId] === undefined) {
                this.completedTasks[taskId] = status;
                const everyTaskDependingOnTaskId = this.reverseTaskDeps[taskId];
                for (let t of everyTaskDependingOnTaskId) {
                    if (this.allDepsAreSuccessful(t)) {
                        yield this.scheduleTask(t);
                    }
                    else if (this.allDepsAreCompleted(t)) {
                        yield this.complete(t, 'skipped');
                    }
                }
            }
            // release blocked threads
            this.waitingForTasks.forEach((f) => f(null));
            this.waitingForTasks.length = 0;
        });
    }
    scheduleTask(taskId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.inProgressTasks[taskId]) {
                this.inProgressTasks[taskId] = true;
                const task = this.taskGraph.tasks[taskId];
                const { value, details } = yield this.hashTask(task);
                task.hash = value;
                task.hashDetails = details;
                this.scheduledTasks.push(taskId);
                // TODO vsavkin: remove the if statement after Nx 14 is out
                if (this.options.lifeCycle.scheduleTask) {
                    this.options.lifeCycle.scheduleTask(task);
                }
            }
        });
    }
    allDepsAreSuccessful(taskId) {
        for (let t of this.taskGraph.dependencies[taskId]) {
            if (this.completedTasks[t] !== 'success' &&
                this.completedTasks[t] !== 'cache')
                return false;
        }
        return true;
    }
    allDepsAreCompleted(taskId) {
        for (let t of this.taskGraph.dependencies[taskId]) {
            if (this.completedTasks[t] === undefined)
                return false;
        }
        return true;
    }
    hashTask(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const hasher = this.customHasher(task);
            if (hasher) {
                return hasher(task, this.taskGraph, this.hasher);
            }
            else {
                return this.hasher.hashTaskWithDepsAndContext(task);
            }
        });
    }
    runTasks() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const that = this;
            function takeFromQueue() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // completed all the tasks
                    if (Object.keys(that.completedTasks).length ===
                        Object.keys(that.taskGraph.tasks).length) {
                        return null;
                    }
                    const task = that.nextTask();
                    if (!task) {
                        // block until some other task completes, then try again
                        return new Promise((res) => that.waitingForTasks.push(res)).then(takeFromQueue);
                    }
                    const doNotSkipCache = that.options.skipNxCache === false ||
                        that.options.skipNxCache === undefined;
                    const cachedResult = yield that.cache.get(task);
                    if (cachedResult && cachedResult.code === 0 && doNotSkipCache) {
                        that.applyCachedResult({ task, cachedResult });
                        yield that.complete(task.id, 'cache');
                        return takeFromQueue();
                    }
                    that.storeStartTime(task);
                    try {
                        const code = that.pipeOutputCapture(task)
                            ? yield that.forkProcessPipeOutputCapture(task)
                            : yield that.forkProcessDirectOutputCapture(task);
                        that.storeEndTime(task);
                        yield that.complete(task.id, code === 0 ? 'success' : 'failure');
                        return takeFromQueue();
                    }
                    catch (_a) {
                        yield that.complete(task.id, 'failure');
                        return takeFromQueue();
                    }
                });
            }
            const wait = [];
            // // initial seeding
            const maxParallel = this.options.parallel
                ? this.options.maxParallel || 3
                : 1;
            for (let i = 0; i < maxParallel; ++i) {
                wait.push(takeFromQueue());
            }
            yield Promise.all(wait);
            return Object.keys(this.completedTasks).map((taskId) => {
                if (this.completedTasks[taskId] === 'cache') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskCacheRead,
                        success: true,
                    };
                }
                else if (this.completedTasks[taskId] === 'success') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskComplete,
                        success: true,
                    };
                }
                else if (this.completedTasks[taskId] === 'failure') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskComplete,
                        success: false,
                    };
                }
                else if (this.completedTasks[taskId] === 'skipped') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskDependencyFailed,
                        success: false,
                    };
                }
            });
        });
    }
    applyCachedResult(t) {
        this.storeStartTime(t.task);
        this.options.lifeCycle.startTask(t.task);
        const outputs = utils_1.getOutputs(this.projectGraph.nodes, t.task);
        const shouldCopyOutputsFromCache = this.cache.shouldCopyOutputsFromCache(t, outputs);
        if (shouldCopyOutputsFromCache) {
            this.cache.copyFilesFromCache(t.task.hash, t.cachedResult, outputs);
        }
        if ((!this.initiatingProject ||
            this.initiatingProject === t.task.target.project) &&
            !this.hideCachedOutput) {
            const args = this.getCommandArgs(t.task);
            output_1.output.logCommand(`nx ${args.join(' ')}`, shouldCopyOutputsFromCache
                ? output_1.TaskCacheStatus.RetrievedFromCache
                : output_1.TaskCacheStatus.MatchedExistingOutput);
            process.stdout.write(t.cachedResult.terminalOutput);
        }
        this.options.lifeCycle.endTask(t.task, t.cachedResult.code);
        this.storeEndTime(t.task);
    }
    storeStartTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`] = {
            start: new Date().getTime(),
            end: undefined,
        };
    }
    storeEndTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`].end = new Date().getTime();
    }
    pipeOutputCapture(task) {
        try {
            return this.readExecutor(task).schema.outputCapture === 'pipe';
        }
        catch (e) {
            return false;
        }
    }
    customHasher(task) {
        try {
            const f = this.readExecutor(task).hasherFactory;
            return f ? f() : null;
        }
        catch (e) {
            console.error(e);
            throw new Error(`Unable to load hasher for task "${task.id}"`);
        }
    }
    readExecutor(task) {
        const p = this.projectGraph.nodes[task.target.project];
        const b = p.data.targets[task.target.target].executor;
        const [nodeModule, executor] = b.split(':');
        const w = new workspace_1.Workspaces(this.workspaceRoot);
        return w.readExecutor(nodeModule, executor);
    }
    forkProcessPipeOutputCapture(task) {
        const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
        const outputPath = this.cache.temporaryOutputPath(task);
        return new Promise((res, rej) => {
            try {
                this.options.lifeCycle.startTask(task);
                const forwardOutput = this.shouldForwardOutput(outputPath, task);
                const env = this.envForForkedProcess(task, undefined, forwardOutput, process.env.FORCE_COLOR === undefined
                    ? 'true'
                    : process.env.FORCE_COLOR);
                const args = this.getCommandArgs(task);
                const commandLine = `nx ${args.join(' ')}`;
                if (forwardOutput) {
                    output_1.output.logCommand(commandLine);
                }
                this.cache.removeRecordedOutputsHashes(taskOutputs);
                const p = child_process_1.fork(this.getCommand(), args, {
                    stdio: ['inherit', 'pipe', 'pipe', 'ipc'],
                    env,
                });
                this.processes.push(p);
                let out = [];
                let outWithErr = [];
                p.stdout.on('data', (chunk) => {
                    if (forwardOutput) {
                        process.stdout.write(chunk);
                    }
                    out.push(chunk.toString());
                    outWithErr.push(chunk.toString());
                });
                p.stderr.on('data', (chunk) => {
                    if (forwardOutput) {
                        process.stderr.write(chunk);
                    }
                    outWithErr.push(chunk.toString());
                });
                p.on('exit', (code, signal) => {
                    if (code === null)
                        code = this.signalToCode(signal);
                    // we didn't print any output as we were running the command
                    // print all the collected output|
                    if (!forwardOutput) {
                        output_1.output.logCommand(commandLine);
                        process.stdout.write(outWithErr.join(''));
                    }
                    if (outputPath) {
                        const terminalOutput = outWithErr.join('');
                        fs_1.writeFileSync(outputPath, terminalOutput);
                        if (this.shouldCacheTask(outputPath, code)) {
                            this.cache
                                .put(task, terminalOutput, taskOutputs, code)
                                .then(() => {
                                this.cache.recordOutputsHash(taskOutputs, task.hash);
                                this.options.lifeCycle.endTask(task, code);
                                res(code);
                            })
                                .catch((e) => {
                                rej(e);
                            });
                        }
                        else {
                            this.cache.recordOutputsHash(taskOutputs, task.hash);
                            this.options.lifeCycle.endTask(task, code);
                            res(code);
                        }
                    }
                    else {
                        this.cache.recordOutputsHash(taskOutputs, task.hash);
                        this.options.lifeCycle.endTask(task, code);
                        res(code);
                    }
                });
            }
            catch (e) {
                console.error(e);
                rej(e);
            }
        });
    }
    forkProcessDirectOutputCapture(task) {
        const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
        const outputPath = this.cache.temporaryOutputPath(task);
        return new Promise((res, rej) => {
            try {
                this.options.lifeCycle.startTask(task);
                const forwardOutput = this.shouldForwardOutput(outputPath, task);
                const env = this.envForForkedProcess(task, outputPath, forwardOutput, undefined);
                const args = this.getCommandArgs(task);
                const commandLine = `nx ${args.join(' ')}`;
                if (forwardOutput) {
                    output_1.output.logCommand(commandLine);
                }
                this.cache.removeRecordedOutputsHashes(taskOutputs);
                const p = child_process_1.fork(this.getCommand(), args, {
                    stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                    env,
                });
                this.processes.push(p);
                p.on('exit', (code, signal) => {
                    if (code === null)
                        code = this.signalToCode(signal);
                    // we didn't print any output as we were running the command
                    // print all the collected output
                    if (!forwardOutput) {
                        output_1.output.logCommand(commandLine);
                        const terminalOutput = this.readTerminalOutput(outputPath);
                        if (terminalOutput) {
                            process.stdout.write(terminalOutput);
                        }
                        else {
                            console.error(`Nx could not find process's output. Run the command without --parallel.`);
                        }
                    }
                    // we don't have to worry about this statement. code === 0 guarantees the file is there.
                    if (this.shouldCacheTask(outputPath, code)) {
                        this.cache
                            .put(task, this.readTerminalOutput(outputPath), taskOutputs, code)
                            .then(() => {
                            this.cache.recordOutputsHash(taskOutputs, task.hash);
                            this.options.lifeCycle.endTask(task, code);
                            res(code);
                        })
                            .catch((e) => {
                            rej(e);
                        });
                    }
                    else {
                        this.cache.recordOutputsHash(taskOutputs, task.hash);
                        this.options.lifeCycle.endTask(task, code);
                        res(code);
                    }
                });
            }
            catch (e) {
                console.error(e);
                rej(e);
            }
        });
    }
    readTerminalOutput(outputPath) {
        try {
            return fs_1.readFileSync(outputPath).toString();
        }
        catch (e) {
            return null;
        }
    }
    shouldCacheTask(outputPath, code) {
        // TODO: vsavkin make caching failures the default in Nx 12.1
        if (process.env.NX_CACHE_FAILURES == 'true') {
            return outputPath;
        }
        else {
            return outputPath && code === 0;
        }
    }
    envForForkedProcess(task, outputPath, forwardOutput, forceColor) {
        const envsFromFiles = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, parseEnv('.env')), parseEnv('.local.env')), parseEnv('.env.local')), parseEnv(`${task.projectRoot}/.env`)), parseEnv(`${task.projectRoot}/.local.env`)), parseEnv(`${task.projectRoot}/.env.local`));
        const env = Object.assign(Object.assign(Object.assign(Object.assign({}, envsFromFiles), { FORCE_COLOR: forceColor }), process.env), { NX_TASK_HASH: task.hash, NX_INVOKED_BY_RUNNER: 'true', NX_WORKSPACE_ROOT: this.workspaceRoot });
        if (outputPath) {
            env.NX_TERMINAL_OUTPUT_PATH = outputPath;
            if (this.options.captureStderr) {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            // TODO: remove this once we have a reasonable way to configure it
            if (task.target.target === 'test') {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            if (forwardOutput) {
                env.NX_FORWARD_OUTPUT = 'true';
            }
        }
        return env;
    }
    shouldForwardOutput(outputPath, task) {
        if (!outputPath)
            return true;
        if (!this.options.parallel)
            return true;
        if (task.target.project === this.initiatingProject)
            return true;
        return false;
    }
    getCommand() {
        const cli = require.resolve(`@nrwl/cli/lib/run-cli.js`, {
            paths: [this.workspaceRoot],
        });
        return `${cli}`;
    }
    getCommandArgs(task) {
        const args = utils_1.unparse(task.overrides || {});
        const config = task.target.configuration
            ? `:${task.target.configuration}`
            : '';
        return [
            'run',
            `${task.target.project}:${task.target.target}${config}`,
            ...args,
        ];
    }
    setupOnProcessExitListener() {
        process.on('SIGINT', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // we exit here because we don't need to write anything to cache.
            process.exit();
        });
        process.on('SIGTERM', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // no exit here because we expect child processes to terminate which
            // will store results to the cache and will terminate this process
        });
        process.on('SIGHUP', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // no exit here because we expect child processes to terminate which
            // will store results to the cache and will terminate this process
        });
    }
    signalToCode(signal) {
        if (signal === 'SIGHUP')
            return 128 + 1;
        if (signal === 'SIGINT')
            return 128 + 2;
        if (signal === 'SIGTERM')
            return 128 + 15;
        return 128;
    }
}
exports.TaskOrchestrator = TaskOrchestrator;
function parseEnv(path) {
    try {
        const envContents = fs_1.readFileSync(path);
        return dotenv.parse(envContents);
    }
    catch (e) { }
}
//# sourceMappingURL=task-orchestrator.js.map