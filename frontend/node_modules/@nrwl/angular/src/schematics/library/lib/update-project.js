"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProject = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const path = require("path");
const update_ng_package_1 = require("./update-ng-package");
const devkit_1 = require("@nrwl/devkit");
// TODO - refactor this into separate rules with better names
function updateProject(options) {
    return schematics_1.chain([
        (host, _context) => {
            const libRoot = `${options.projectRoot}/src/lib/`;
            const serviceSpecPath = path.join(libRoot, `${options.name}.service.spec.ts`);
            const componentSpecPath = path.join(libRoot, `${options.name}.component.spec.ts`);
            host.delete(path.join(libRoot, `${options.name}.service.ts`));
            if (host.exists(serviceSpecPath)) {
                host.delete(serviceSpecPath);
            }
            host.delete(path.join(libRoot, `${options.name}.component.ts`));
            if (host.exists(componentSpecPath)) {
                host.delete(path.join(libRoot, `${options.name}.component.spec.ts`));
            }
            if (!options.publishable && !options.buildable) {
                host.delete(path.join(options.projectRoot, 'ng-package.json'));
                host.delete(path.join(options.projectRoot, 'package.json'));
                host.delete(path.join(options.projectRoot, 'tsconfig.lib.prod.json'));
            }
            host.delete(path.join(options.projectRoot, 'karma.conf.js'));
            host.delete(path.join(options.projectRoot, 'src/test.ts'));
            host.delete(path.join(options.projectRoot, 'tsconfig.spec.json'));
            host.delete(path.join(libRoot, `${options.name}.module.ts`));
            host.create(path.join(libRoot, `${options.fileName}.module.ts`), `
            import { NgModule } from '@angular/core';
            import { CommonModule } from '@angular/common';
            
            @NgModule({
              imports: [
                CommonModule
              ]
            })
            export class ${options.moduleName} { }
            `);
            if (options.unitTestRunner !== 'none' && options.addModuleSpec) {
                host.create(path.join(libRoot, `${options.fileName}.module.spec.ts`), `
        import { async, TestBed } from '@angular/core/testing';
        import { ${options.moduleName} } from './${options.fileName}.module';
        
        describe('${options.moduleName}', () => {
          beforeEach(async(() => {
            TestBed.configureTestingModule({
              imports: [ ${options.moduleName} ]
            })
            .compileComponents();
          }));
        
          // TODO: Add real tests here.
          //
          // NB: This particular test does not do anything useful. 
          //     It does NOT check for correct instantiation of the module.
          it('should have a module definition', () => {
            expect(${options.moduleName}).toBeDefined();
          });
        });
              `);
            }
            host.overwrite(`${options.projectRoot}/src/index.ts`, `
            export * from './lib/${options.fileName}.module';
            `);
            return host;
        },
        schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files/lib'), [
            schematics_1.template(Object.assign(Object.assign({}, options), { offsetFromRoot: devkit_1.offsetFromRoot(options.projectRoot) })),
            schematics_1.move(options.projectRoot),
        ]), schematics_1.MergeStrategy.Overwrite),
        (host) => {
            return workspace_1.updateJsonInTree(workspace_1.getWorkspacePath(host), (json) => {
                const project = json.projects[options.name];
                const fixedProject = workspace_1.replaceAppNameWithPath(project, options.name, options.projectRoot);
                delete fixedProject.schematics;
                if (!options.publishable && !options.buildable) {
                    delete fixedProject.architect.build;
                }
                else {
                    if (options.publishable) {
                        // adjust the builder path to our custom one
                        fixedProject.architect.build.builder = '@nrwl/angular:package';
                    }
                    else {
                        // adjust the builder path to our custom one
                        fixedProject.architect.build.builder =
                            '@nrwl/angular:ng-packagr-lite';
                    }
                }
                delete fixedProject.architect.test;
                json.projects[options.name] = fixedProject;
                return json;
            });
        },
        workspace_1.updateJsonInTree(`${options.projectRoot}/tsconfig.lib.json`, (json) => {
            if (options.unitTestRunner === 'jest') {
                json.exclude = ['src/test-setup.ts', '**/*.spec.ts'];
            }
            else if (options.unitTestRunner === 'none') {
                json.exclude = [];
            }
            else {
                json.exclude = json.exclude || [];
            }
            return Object.assign(Object.assign({}, json), { extends: `./tsconfig.json`, compilerOptions: Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${devkit_1.offsetFromRoot(options.projectRoot)}dist/out-tsc` }) });
        }),
        workspace_1.updateJsonInTree(`/nx.json`, (json) => (Object.assign(Object.assign({}, json), { projects: Object.assign(Object.assign({}, json.projects), { [options.name]: { tags: options.parsedTags } }) }))),
        (host) => update_ng_package_1.updateNgPackage(host, options),
    ]);
}
exports.updateProject = updateProject;
//# sourceMappingURL=update-project.js.map