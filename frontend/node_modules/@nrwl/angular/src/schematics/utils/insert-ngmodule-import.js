"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertNgModuleImport = void 0;
const devkit_1 = require("@nrwl/devkit");
const typescript_1 = require("typescript");
function insertNgModuleImport(tree, modulePath, importName) {
    const contents = tree.read(modulePath).toString('utf-8');
    const sourceFile = typescript_1.createSourceFile(modulePath, contents, typescript_1.ScriptTarget.ESNext);
    const coreImport = findImport(sourceFile, '@angular/core');
    if (!coreImport) {
        throw new Error(`There are no imports from "@angular/core" in ${modulePath}.`);
    }
    const ngModuleNamedImport = getNamedImport(coreImport, 'NgModule');
    const ngModuleName = ngModuleNamedImport.name.escapedText;
    const ngModuleClassDeclaration = findDecoratedClass(sourceFile, ngModuleName);
    const ngModuleDecorator = ngModuleClassDeclaration.decorators.find((decorator) => typescript_1.isCallExpression(decorator.expression) &&
        typescript_1.isIdentifier(decorator.expression.expression) &&
        decorator.expression.expression.escapedText === ngModuleName);
    const ngModuleCall = ngModuleDecorator.expression;
    if (ngModuleCall.arguments.length < 1) {
        const newContents = devkit_1.applyChangesToString(contents, [
            {
                type: devkit_1.ChangeType.Insert,
                index: ngModuleCall.getEnd() - 1,
                text: `{ imports: [${importName}]}`,
            },
        ]);
        tree.write(modulePath, newContents);
    }
    else {
        if (!typescript_1.isObjectLiteralExpression(ngModuleCall.arguments[0])) {
            throw new Error(`The NgModule options for ${ngModuleClassDeclaration.name.escapedText} in ${modulePath} is not an object literal`);
        }
        const ngModuleOptions = ngModuleCall
            .arguments[0];
        const importsProperty = findPropertyAssignment(ngModuleOptions);
        if (!importsProperty) {
            let text = `imports: [${importName}]`;
            if (ngModuleOptions.properties.hasTrailingComma) {
                text = `${text},`;
            }
            else {
                text = `, ${text}`;
            }
            const newContents = devkit_1.applyChangesToString(contents, [
                {
                    type: devkit_1.ChangeType.Insert,
                    index: ngModuleOptions.getEnd() - 1,
                    text,
                },
            ]);
            tree.write(modulePath, newContents);
        }
        else {
            if (!typescript_1.isArrayLiteralExpression(importsProperty.initializer)) {
                throw new Error(`The NgModule imports for ${ngModuleClassDeclaration.name.escapedText} in ${modulePath} is not an array literal`);
            }
            let text;
            if (importsProperty.initializer.elements.hasTrailingComma) {
                text = `${importName},`;
            }
            else {
                text = `, ${importName}`;
            }
            const newContents = devkit_1.applyChangesToString(contents, [
                {
                    type: devkit_1.ChangeType.Insert,
                    index: importsProperty.initializer.getEnd() - 1,
                    text,
                },
            ]);
            tree.write(modulePath, newContents);
        }
    }
}
exports.insertNgModuleImport = insertNgModuleImport;
function findImport(sourceFile, importPath) {
    const importStatements = sourceFile.statements.filter(typescript_1.isImportDeclaration);
    return importStatements.find((statement) => statement.moduleSpecifier
        .getText(sourceFile)
        .replace(/['"`]/g, '')
        .trim() === importPath);
}
function getNamedImport(coreImport, importName) {
    if (!typescript_1.isNamedImports(coreImport.importClause.namedBindings)) {
        throw new Error(`The import from ${coreImport.moduleSpecifier} does not have named imports.`);
    }
    return coreImport.importClause.namedBindings.elements.find((namedImport) => namedImport.propertyName
        ? typescript_1.isIdentifier(namedImport.propertyName) &&
            namedImport.propertyName.escapedText === importName
        : typescript_1.isIdentifier(namedImport.name) &&
            namedImport.name.escapedText === importName);
}
function findDecoratedClass(sourceFile, ngModuleName) {
    const classDeclarations = sourceFile.statements.filter(typescript_1.isClassDeclaration);
    return classDeclarations.find((declaration) => declaration.decorators &&
        declaration.decorators.some((decorator) => typescript_1.isCallExpression(decorator.expression) &&
            typescript_1.isIdentifier(decorator.expression.expression) &&
            decorator.expression.expression.escapedText === ngModuleName));
}
function findPropertyAssignment(ngModuleOptions) {
    return ngModuleOptions.properties.find((property) => typescript_1.isPropertyAssignment(property) &&
        typescript_1.isIdentifier(property.name) &&
        property.name.escapedText === 'imports');
}
//# sourceMappingURL=insert-ngmodule-import.js.map