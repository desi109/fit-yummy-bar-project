"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addImportsToModule = void 0;
const ts = require("typescript");
const workspace_1 = require("@nrwl/workspace");
const ast_utils_1 = require("../../../utils/ast-utils");
const ast_utils_2 = require("@nrwl/workspace/src/utils/ast-utils");
const devkit_1 = require("@nrwl/devkit");
function addImportsToModule(context) {
    return (host) => {
        const modulePath = context.options.module;
        const sourceText = host.read(modulePath).toString('utf-8');
        const source = ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);
        const addImport = (symbolName, fileName, isDefault = false) => {
            return ast_utils_2.insertImport(source, modulePath, symbolName, fileName, isDefault);
        };
        const dir = `./${devkit_1.names(context.options.directory).fileName}`;
        const pathPrefix = `${dir}/${devkit_1.names(context.featureName).fileName}`;
        const reducerPath = `${pathPrefix}.reducer`;
        const effectsPath = `${pathPrefix}.effects`;
        const facadePath = `${pathPrefix}.facade`;
        const constantName = `${devkit_1.names(context.featureName).constantName}`;
        const effectsName = `${devkit_1.names(context.featureName).className}Effects`;
        const facadeName = `${devkit_1.names(context.featureName).className}Facade`;
        const className = `${devkit_1.names(context.featureName).className}`;
        const reducerImports = `* as from${className}`;
        const storeMetaReducers = `metaReducers: !environment.production ? [] : []`;
        const storeForRoot = `StoreModule.forRoot({},
  {
    ${storeMetaReducers},
    runtimeChecks: {
      strictActionImmutability: true,
      strictStateImmutability: true
    }
  }
)`;
        const nxModule = 'NxModule.forRoot()';
        const effectsForRoot = `EffectsModule.forRoot([${effectsName}])`;
        const effectsForEmptyRoot = `EffectsModule.forRoot([])`;
        const storeForFeature = `StoreModule.forFeature(from${className}.${constantName}_FEATURE_KEY, from${className}.reducer)`;
        const effectsForFeature = `EffectsModule.forFeature([${effectsName}])`;
        const devTools = `!environment.production ? StoreDevtoolsModule.instrument() : []`;
        const storeRouterModule = 'StoreRouterConnectingModule.forRoot()';
        // InsertImport [symbol,source] value pairs
        const nxModuleImport = ['NxModule', '@nrwl/angular'];
        const storeModule = ['StoreModule', '@ngrx/store'];
        const effectsModule = ['EffectsModule', '@ngrx/effects'];
        const storeDevTools = ['StoreDevtoolsModule', '@ngrx/store-devtools'];
        const environment = ['environment', '../environments/environment'];
        const storeRouter = ['StoreRouterConnectingModule', '@ngrx/router-store'];
        // this is just a heuristic
        const hasRouter = sourceText.indexOf('RouterModule') > -1;
        const hasNxModule = sourceText.includes('NxModule.forRoot()');
        if ((context.options.onlyEmptyRoot || context.options.minimal) &&
            context.options.root) {
            workspace_1.insert(host, modulePath, [
                addImport.apply(this, storeModule),
                addImport.apply(this, effectsModule),
                addImport.apply(this, storeDevTools),
                addImport.apply(this, environment),
                ...(hasRouter ? [addImport.apply(this, storeRouter)] : []),
                ...ast_utils_1.addImportToModule(source, modulePath, storeForRoot),
                ...ast_utils_1.addImportToModule(source, modulePath, effectsForEmptyRoot),
                ...ast_utils_1.addImportToModule(source, modulePath, devTools),
                ...(hasRouter
                    ? ast_utils_1.addImportToModule(source, modulePath, storeRouterModule)
                    : []),
            ]);
        }
        else {
            let common = [
                addImport.apply(this, storeModule),
                addImport.apply(this, effectsModule),
                addImport(reducerImports, reducerPath, true),
                addImport(effectsName, effectsPath),
            ];
            if (context.options.facade) {
                common = [
                    ...common,
                    addImport(facadeName, facadePath),
                    ...ast_utils_1.addProviderToModule(source, modulePath, `${facadeName}`),
                ];
            }
            if (context.options.root) {
                workspace_1.insert(host, modulePath, [
                    ...common,
                    ...(!hasNxModule ? [addImport.apply(this, nxModuleImport)] : []),
                    addImport.apply(this, storeDevTools),
                    addImport.apply(this, environment),
                    ...(hasRouter ? [addImport.apply(this, storeRouter)] : []),
                    ...(!hasNxModule
                        ? ast_utils_1.addImportToModule(source, modulePath, nxModule)
                        : []),
                    ...ast_utils_1.addImportToModule(source, modulePath, storeForRoot),
                    ...ast_utils_1.addImportToModule(source, modulePath, effectsForRoot),
                    ...ast_utils_1.addImportToModule(source, modulePath, devTools),
                    ...(hasRouter
                        ? ast_utils_1.addImportToModule(source, modulePath, storeRouterModule)
                        : []),
                    ...ast_utils_1.addImportToModule(source, modulePath, storeForFeature),
                ]);
            }
            else {
                workspace_1.insert(host, modulePath, [
                    ...common,
                    ...ast_utils_1.addImportToModule(source, modulePath, storeForFeature),
                    ...ast_utils_1.addImportToModule(source, modulePath, effectsForFeature),
                ]);
            }
        }
        return host;
    };
}
exports.addImportsToModule = addImportsToModule;
//# sourceMappingURL=add-imports-to-module.js.map