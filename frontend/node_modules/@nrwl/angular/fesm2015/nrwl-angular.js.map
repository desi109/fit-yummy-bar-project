{"version":3,"file":"nrwl-angular.js","sources":["../../src/runtime/nx/data-persistence.ts","../../src/runtime/nx/nx.module.ts","../../nrwl-angular.ts"],"sourcesContent":["import { Injectable, Type } from '@angular/core';\nimport { ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\nimport { Actions, ofType } from '@ngrx/effects';\nimport { ROUTER_NAVIGATION, RouterNavigationAction } from '@ngrx/router-store';\nimport { Action, Store, ActionCreator } from '@ngrx/store';\nimport { isObservable, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  filter,\n  groupBy,\n  map,\n  mergeMap,\n  switchMap,\n  withLatestFrom,\n} from 'rxjs/operators';\n\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface PessimisticUpdateOpts<T, A> {\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  onError(a: A, e: any): Observable<any> | any;\n}\n/**\n * See {@link DataPersistence.pessimisticUpdate} for more information.\n */\nexport interface OptimisticUpdateOpts<T, A> {\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  undoAction(a: A, e: any): Observable<Action> | Action;\n}\n\n/**\n * See {@link DataPersistence.fetch} for more information.\n */\nexport interface FetchOpts<T, A> {\n  id?(a: A, state?: T): any;\n  run(a: A, state?: T): Observable<Action> | Action | void;\n  onError?(a: A, e: any): Observable<any> | any;\n}\n\n/**\n * See {@link DataPersistence.navigation} for more information.\n */\nexport interface HandleNavigationOpts<T> {\n  run(a: ActivatedRouteSnapshot, state?: T): Observable<Action> | Action | void;\n  onError?(a: ActivatedRouteSnapshot, e: any): Observable<any> | any;\n}\n\nexport type ActionOrActionWithState<T, A> = A | [A, T];\nexport type ActionStateStream<T, A> = Observable<ActionOrActionWithState<T, A>>;\n\nexport function pessimisticUpdate<T, A extends Action>(\n  opts: PessimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function optimisticUpdate<T, A extends Action>(\n  opts: OptimisticUpdateOpts<T, A>\n) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.undoAction))\n    );\n  };\n}\n\nexport function fetch<T, A extends Action>(opts: FetchOpts<T, A>) {\n  return (source: ActionStateStream<T, A>): Observable<Action> => {\n    if (opts.id) {\n      const groupedFetches = source.pipe(\n        mapActionAndState(),\n        groupBy(([action, store]) => {\n          return opts.id(action, store);\n        })\n      );\n\n      return groupedFetches.pipe(\n        mergeMap((pairs) =>\n          pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))\n        )\n      );\n    }\n\n    return source.pipe(\n      mapActionAndState(),\n      concatMap(runWithErrorHandling(opts.run, opts.onError))\n    );\n  };\n}\n\nexport function navigation<T, A extends Action>(\n  component: Type<any>,\n  opts: HandleNavigationOpts<T>\n) {\n  return (source: ActionStateStream<T, A>) => {\n    const nav = source.pipe(\n      mapActionAndState(),\n      filter(([action, state]) => isStateSnapshot(action)),\n      map(([action, state]) => {\n        if (!isStateSnapshot(action)) {\n          // Because of the above filter we'll never get here,\n          // but this properly type narrows `action`\n          return;\n        }\n\n        return [\n          findSnapshot(component, action.payload.routerState.root),\n          state,\n        ] as [ActivatedRouteSnapshot, T];\n      }),\n      filter(([snapshot, state]) => !!snapshot)\n    );\n\n    return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n\nfunction isStateSnapshot(\n  action: any\n): action is RouterNavigationAction<RouterStateSnapshot> {\n  return action.type === ROUTER_NAVIGATION;\n}\n\nfunction runWithErrorHandling<T, A, R>(\n  run: (a: A, state?: T) => Observable<R> | R | void,\n  onError: any\n) {\n  return ([action, state]: [A, T]): Observable<R> => {\n    try {\n      const r = wrapIntoObservable(run(action, state));\n      return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));\n    } catch (e) {\n      return wrapIntoObservable(onError(action, e));\n    }\n  };\n}\n\n/**\n * @whatItDoes maps Observable<Action | [Action, State]> to\n * Observable<[Action, State]>\n */\nfunction mapActionAndState<T, A>() {\n  return (source: Observable<ActionOrActionWithState<T, A>>) => {\n    return source.pipe(\n      map((value) => {\n        const [action, store] = normalizeActionAndState(value);\n        return [action, store] as [A, T];\n      })\n    );\n  };\n}\n\n/**\n * @whatItDoes Normalizes either a bare action or an array of action and state\n * into an array of action and state (or undefined)\n */\nfunction normalizeActionAndState<T, A>(\n  args: ActionOrActionWithState<T, A>\n): [A, T] {\n  let action: A, state: T;\n\n  if (args instanceof Array) {\n    [action, state] = args;\n  } else {\n    action = args;\n  }\n\n  return [action, state];\n}\n\n/**\n * @whatItDoes Provides convenience methods for implementing common operations of persisting data.\n */\n@Injectable()\nexport class DataPersistence<T> {\n  constructor(public store: Store<T>, public actions: Actions) {}\n\n  /**\n   *\n   * @whatItDoes Handles pessimistic updates (updating the server first).\n   *\n   * Update the server implemented naively suffers from race conditions and poor error handling.\n   *\n   * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run(a, state) {\n   *       // update the backend first, and then dispatch an action that will\n   *       // update the client side\n   *       return this.backend(state.user, a.payload).map(updated => ({\n   *         type: 'TODO_UPDATED',\n   *         payload: updated\n   *       }));\n   *     },\n   *\n   *     onError(a, e: any) {\n   *       // we don't need to undo the changes on the client side.\n   *       // we can dispatch an error, or simply log the error here and return `null`\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  pessimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: PessimisticUpdateOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      pessimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles optimistic updates (updating the client first).\n   *\n   * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n   * the developer already updated the state locally, so the developer must provide an undo action.\n   *\n   * The error handling must be done in the callback, or by means of the undo action.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload);\n   *     },\n   *\n   *     undoAction: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return ({\n   *         type: 'UNDO_UPDATE_TODO',\n   *         payload: a\n   *       });\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * Note that if you don't return a new action from the run callback, you must set the dispatch property\n   * of the effect to false, like this:\n   *\n   * ```\n   * class TodoEffects {\n   *   @Effect({dispatch: false})\n   *   updateTodo; //...\n   * }\n   * ```\n   */\n  optimisticUpdate<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: OptimisticUpdateOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      optimisticUpdate(opts)\n    );\n  }\n\n  /**\n   *\n   * @whatItDoes Handles data fetching.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n   * and forces the developer to handle errors.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODOS',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * This is correct, but because it set the concurrency to 1, it may not be performant.\n   *\n   * To fix that, you can provide the `id` function, like this:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n   *     id: (a, state) => {\n   *       return a.payload.id;\n   *     }\n   *\n   *     // provides an action and the current state of the store\n   *     run: (a, state) => {\n   *       return this.backend(state.user, a.payload).map(r => ({\n   *         type: 'TODO',\n   *         payload: r\n   *       });\n   *     },\n   *\n   *     onError: (a, e: any) => {\n   *       // dispatch an undo action to undo the changes in the client state\n   *       return null;\n   *     }\n   *   });\n   *\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   *\n   * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n   *\n   * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n   * it will only run the last one.\n   */\n  fetch<A extends Action = Action>(\n    actionType: string | ActionCreator,\n    opts: FetchOpts<T, A>\n  ): Observable<any> {\n    return this.actions.pipe(\n      ofType<A>(actionType),\n      withLatestFrom(this.store),\n      fetch(opts)\n    );\n  }\n\n  /**\n   * @whatItDoes Handles data fetching as part of router navigation.\n   *\n   * Data fetching implemented naively suffers from race conditions and poor error handling.\n   *\n   * `navigation` addresses these problems.\n   *\n   * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n   * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n   * the last request.\n   *\n   * ## Example:\n   *\n   * ```typescript\n   * @Injectable()\n   * class TodoEffects {\n   *   @Effect() loadTodo = this.s.navigation(TodoComponent, {\n   *     run: (a, state) => {\n   *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n   *         type: 'TODO_LOADED',\n   *         payload: todo\n   *       }));\n   *     },\n   *     onError: (a, e: any) => {\n   *       // we can log and error here and return null\n   *       // we can also navigate back\n   *       return null;\n   *     }\n   *   });\n   *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n   * }\n   * ```\n   */\n  navigation(\n    component: Type<any>,\n    opts: HandleNavigationOpts<T>\n  ): Observable<any> {\n    return this.actions.pipe(\n      withLatestFrom(this.store),\n      navigation(component, opts)\n    );\n  }\n}\n\nfunction findSnapshot(\n  component: Type<any>,\n  s: ActivatedRouteSnapshot\n): ActivatedRouteSnapshot {\n  if (s.routeConfig && s.routeConfig.component === component) {\n    return s;\n  }\n  for (const c of s.children) {\n    const ss = findSnapshot(component, c);\n    if (ss) {\n      return ss;\n    }\n  }\n  return null;\n}\n\nfunction wrapIntoObservable<O>(obj: Observable<O> | O | void): Observable<O> {\n  if (isObservable(obj)) {\n    return obj;\n  } else if (!obj) {\n    return of();\n  } else {\n    return of(obj as O);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { DataPersistence } from './data-persistence';\n\n/**\n * @whatItDoes Provides services for enterprise Angular applications.\n *\n * See {@link DataPersistence} for more information.\n */\n@NgModule({})\nexport class NxModule {\n  static forRoot(): ModuleWithProviders<NxModule> {\n    return { ngModule: NxModule, providers: [DataPersistence] };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}